/*
    题目
    
    输入一个非负数n，请计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。
    例如，输入的n为4，由于0、1、2、3、4的二进制形式中1的个数分别为0、1、1、2、1，因此输出数组[0, 1, 1, 2, 1]
*/

/*
    分析

    很多人面试想到直观解法，使用一个for循环来计算0到n的每个整数i的二进制中1的个数。于是问题转换成如何求一个整数的二进制形式中1的个数。

    思路a -- 简单计算每个整数的二进制形式中1的个数

        每次用"i&(i-1)"将整数i的最右边的1变成0。整数i减去1，那么它的最右边的1变成0。如果它的右边还有0，则右边所有的0都变成1，而其左边的所有位保持不变。
        以二进制1100为例，它减去1的结果时1011，1100和1011的位与运算结果正好时1000。
        如果一个整数有K位，那么它的二进制形式中可能有O(k)个1。在本方法代码中，while循环对每个整数执行O(k)次，因此上述代码时间复杂度位O(nk)。

    思路b -- 根据“i&(i-1)”计算i的二进制形式中1的个数

        也就是说，i的二进制数比“i&(i-1)”的二进制数中1的个数多1
        不管i中有多少个1，此思路只根据O(1)的时间就能得出i的二进制中1的数目，则总的时间复杂度为O(n)

    思路c -- 根据“i/2”计算i的二进制形式中1的个数

        如果正整数i是一个偶数，那么i相当于“i/2”左移1位。因此偶数i与i/2的二进制形式中1的个数相同
        如果i是奇数，i相当于将i/2二进制左移一位再将最右边位设为1，因此奇数i中1的个数比i/2多1个
        例如3的二进制0011，6的二进制0110，7的二进制0111，根据3的二进制1的个数直接求出6和7的二进制1的个数
        代码用i>>1计算i/2，用i&1计算i%2，因为位运算比除法和求余更高效，这个题目时位运算，所以尽量用位运算优化代码，复杂度也是O(n)

*/

namespace AlgorithmsPractice
{
    static partial class AlgorithmBo
    {
        // 思路a, little bad, O(nk)
        static internal int[] CountBitsA(int num)
        {
            var result = new int[num + 1];  // 建立包含从0到n的数组，所以长度是n+1

            for (int i = 0; i <= num; ++i)  // 开始循环遍历数组中每一个数，本循环时间复杂度为O(n)
            {
                int j = i;  // 临时变量j为当前遍历的数字
                while (j != 0)  // 当j不为0时，（继续）进行循环计算1的个数，如上所述，k位的数字，则本循环时间复杂度位O(k)
                {
                    result[i]++;    // 只要能够进入循环，（j不为0）就意味着一定包含1，所以在当前遍历数字里加1计数
                    j = j & (j - 1);    // 将j最右边的1去掉后并赋值给自己，看是否不为0（是否进入下一次while循环）
                }
            }

            return result;  // 结束后，返回数组
        }

        // 思路b, good, O(n)
        public static int[] CountBitsB(int num)
        {
            var result = new int[num + 1];  // 建立包含从0到n的数组，所以长度是n+1，默认初始化都为0

            for (int i = 1; i <= num; ++i)  //  循环遍历1~num每一个数，不用0，因为0的二进制数中1的数肯定为0，复杂度为O(n)
            {
                result[i] = result[i & (i - 1)] + 1;    // 此为关键，因为i&(i-1)一定比i小，那么用result[i & (i - 1)]得到的值一定是经过计算的确定值，每一次计算都利用了前一次计算，复杂度为O(1)
            }

            return result;
        }

        //思路c, good, O(n)
        public static int[] CountBitsC(int num)
        {
            var result = new int[num + 1];  // 建立包含从0到n的数组，所以长度是n+1，默认初始化都为0

            for (int i = 1; i <= num; ++i)  //  循环遍历1~num每一个数，不用0，因为0的二进制数中1的数肯定为0，复杂度为O(n)
            {
                result[i] = result[i >> 1] + (i & 1);   //i>>1 为 i/2，如果i为偶数，则直接等于i/2的1的个数，如果为奇数，则加上1，利用i%2直接作为值（没有先去判断更高效）
            }                                           // 和思路b类似，都是利用前面已经计算好的值，复杂度为O(1)

            return result;
        }
    }
}