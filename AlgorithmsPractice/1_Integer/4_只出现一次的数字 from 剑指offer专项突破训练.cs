/*
    题目

    输入一个整数数组，数组中只有一个数字出现了一次，而其他数字都出现了3次。请找出那个只出现一次的数字。
    例如，如果输入的数组为[0, 1, 0, 1, 0, 1, 100]，则只出现一次的数字是100.
*/

/*
    分析

    这个题目有一个简化版的类似的题目，“输入数组中除一个数字只出现一次之外其他数字都出现两次，请找出只出现一次的数字”
    任何一个数字异或它自己的结果都是0，如果将数组中所有数字进行异或运算，那么最终的结果就是那个只出现一次的数字。
    在这个题目中只有一个数字出现了一次，其他数字都出现了3次，相同的3个数字异或的结果都是数字本身，以上方法并不能消除重复3次的数字。

    Int32是32位0或1组成，可以将数组中所有数字同一个位置的数位相加，如果将出现3次的数字单独拿出来，那么这些出现了3次的数字的任意第i个数位之和都能被3整除。那么只出现一次的数字的第i个数位一定是0
    如果数组中所有数字的第i个数位相加之和被3除余1，那么只出现一次的数字的第i个数位一定是1
    这样只出现一次的任意第i个数位可以由数组中所有数字的第i个数位之和推算出来。当我们知道任意一个整数任意一位是0还是1之后，就可以知道它的数值。

*/

/*
    举一反三

    题目，输入一个整数数组，数组中只有一个数字出现m次，其他数字都出现n次，请找出那个唯一出现m次的数字，假设m不能被n整除。
    分析，如果数组中所有数字的第i个数位相加之和能倍n整除，那么出现m次的数字的第i个数位一定是0，否则出现m次的数字的第i个数位一定是1

*/

namespace AlgorithmsPractice
{
    static partial class AlgorithmBo
    {
        public static int SingleNumber(int[] nums)
        {
            var bitSums = new int[32];  // 基于Int32的长度创建位数组

            foreach (int num in nums)   // 一层循环，遍历每一个传入数组中的数字
            {
                for (int i = 0; i < 32; ++i)    // 二层循环，存储所有数字第i个数位之和在bitSums[i]中
                {
                    bitSums[i] += (num >> (31 - i)) & 1;    // += 意味着不停加上前一次num的位。 num >> (31-i)就是把第i个数字移到最右边
                }                                           // 整数1是最右位为1，其余全部为0，那么任何数与1做位与运算，最终结果都是只保留最右边一位。有符号数右移也无妨
            }                                               // 所以num >> (31-i)与1做位与，就会完整的保留i位的值

            int result = 0;

            for (int i = 0; i < 32; ++i)    // bitSums每一个值，此循环将二进制转换成十进制
            {
                result = (result << 1) + bitSums[i] % 3;    // bitSums[i] % 3只出现一次的数字第i位是0还是1，都是0的话没关系，1的话，如果只出现一次的数没在这个位出现，那么余数肯定是0，否则为1
            }                                               // result << 1 + 负责把第i位（不论+后面是0还是1）从31-i位移到新数字的i位，最后计算出这个数字

            return result;
        }
    }
}