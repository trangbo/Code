/*
    题目
    输入一个递增排序的数组和一个值k，请问如何在数组中找出两个和位k的数字并返回它们的下标？假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。
    例如，输入数组[1,2,4,6,10]，k的值位8，数组中的数字2与6的和位8，它们的下标分别为1与3
*/

/*
    分析
    直观的想法是，先在数组中固定一个数字，再依次判断数组中其余数字与它的和是不是等于k，如果数组的长度是n，由于需要对每个数字与其余n-1个数字求和，所以时间复杂度为O(n^2)
    可以用二分查找来优化，假设扫描到数字i，如果数组中存在另外一个数字k-i，那么就找到了一对和为k的数字。由于数组是递增的，可以用二分查找搜索k-i。二分查找的时间复杂度O(nlogn)，总的优化后时间复杂度也是这个。
    还可以用空间换时间进行优化。先将数组中所有数字都放入哈希表，然后逐一扫描，假设扫到数字i，如果哈希表中存在k-i，就找到一对he为k的数字。判断哈希表中是否存在一个数字时间复杂度为O(1)，
        新解法时间复杂度为O(n)，同时它需要一个空间复杂度为O(n)的哈希表。
    
    存在时间复杂度为O(n)，空间复杂度为O(1)的解法。用两个指针分别指向两个数字，P1指向第一个下标0，P2指向最后一个。如果P1P2的和为K，那么就找到了。
    如果P1P2和比K小，因为是排序好的，那么就把P1向右移动。反之，P2向左移动。
*/

namespace AlgorithmsPractice
{
    static partial class AlgorithmBo
    {
        // 时间复杂度为O(n)，循环执行最多次数最多等于数组长度
        static internal int[] TwoSum(int[] numbers, int target)
        {
            int i = 0, j = numbers.Length - 1;  // 双指针i，j

            while (i < j && numbers[i] + numbers[j] != target)  // 判定条件，i一定小于j，相等或大于都说明没有结果，并且要!=target才进入下一个循环判定
            {
                if (numbers[i] + numbers[j] < target)   // 假如之和小于target，则想再大点，那么i右移
                    i++;
                else        // 反之，j左移
                    j--;
            }

            return new int[] {i, j};    // 最后返回i j
        }
    }
}